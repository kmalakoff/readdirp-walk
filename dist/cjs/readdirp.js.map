{"version":3,"sources":["readdirp.cjs"],"sourcesContent":["const fs = require('fs');\nconst { Readable } = require('stream');\nconst path = require('path');\nconst { promisify } = require('util');\nconst picomatch = require('picomatch');\nconst Iterator = require('fs-iterator');\n\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst FILE_TYPE = 'files';\nconst TEST_DIR_TYPE = 'directories';\nconst FILE_TEST_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, TEST_DIR_TYPE, FILE_TEST_DIR_TYPE, EVERYTHING_TYPE];\n\nconst normalizeFilter = (filter) => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return (entry) => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return (entry) => positive.some((f) => f(entry.basename)) && !negative.some((f) => f(entry.basename));\n      }\n      return (entry) => !negative.some((f) => f(entry.basename));\n    }\n    return (entry) => positive.some((f) => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (_path) => true,\n      directoryFilter: (_path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false,\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096,\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    this._wantsDir = [TEST_DIR_TYPE, FILE_TEST_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_TEST_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = path.resolve(root);\n    this._isDirent = 'Dirent' in fs && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n\n    this.filter = async (entry) => {\n      entry[this._statsProp] = entry.stats;\n      entry.entryType = await this._getEntryType(entry);\n      if (entry.entryType === 'directory') return this._directoryFilter(entry);\n      if (entry.entryType === 'file' || this._includeAsFile(entry)) return this._fileFilter(entry);\n      return true;\n    };\n\n    this.iterator = new Iterator(root, {\n      lstat: opts.lstat,\n      depth: opts.depth,\n      alwaysStat: opts.alwaysStat,\n      filter: this.filter.bind(this),\n      error: this._onError.bind(this),\n    });\n  }\n\n  destroy(err) {\n    super.destroy(err);\n    if (this.iterator) {\n      this.iterator.destroy();\n      this.iterator = null;\n    }\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const done = await this.iterator.forEach(\n          async (entry) => {\n            if (!this.destroyed && ((entry.entryType === 'directory' && this._wantsDir) || (entry.entryType === 'file' && this._wantsFile))) {\n              batch--;\n              this.push(entry);\n            }\n          },\n          {\n            limit: batch,\n          }\n        );\n        if (done) {\n          this.push(null);\n          break;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  _onError(err) {\n    if (this.destroyed) return false;\n    if (~Iterator.EXPECTED_ERRORS.indexOf(err.code)) {\n      this.emit('warn', err);\n      return true;\n    }\n    if (!this.destroyed) this.destroy(err);\n    return false;\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      try {\n        let entryRealPathStats = entry.realStats;\n        if (!entryRealPathStats) {\n          const entryRealPath = await realpath(entry.fullPath);\n          entryRealPathStats = await lstat(entryRealPath);\n        }\n\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_TEST_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  }\n  if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  }\n  if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', (entry) => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', (error) => reject(error));\n  });\n};\n\nmodule.exports = {\n  readdirp,\n  promise: readdirpPromise,\n  ReaddirpStream\n}\n"],"names":["fs","require","Readable","path","promisify","picomatch","Iterator","lstat","realpath","BANG","FILE_TYPE","TEST_DIR_TYPE","FILE_TEST_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","normalizeFilter","filter","undefined","glob","trim","entry","basename","Array","isArray","positive","negative","item","trimmed","charAt","push","slice","length","some","f","ReaddirpStream","options","objectMode","autoDestroy","highWaterMark","opts","defaultOptions","root","type","_fileFilter","fileFilter","_directoryFilter","directoryFilter","_wantsDir","includes","_wantsFile","_wantsEverything","_root","resolve","_isDirent","alwaysStat","_statsProp","stats","_getEntryType","entryType","_includeAsFile","iterator","depth","bind","error","_onError","destroy","err","_read","batch","done","reading","destroyed","forEach","limit","EXPECTED_ERRORS","indexOf","code","emit","entryRealPathStats","entryRealPath","isFile","isDirectory","isSymbolicLink","realStats","fullPath","_path","readdirp","Error","TypeError","join","readdirpPromise","Promise","reject","files","on","module","exports","promise"],"mappings":"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"}